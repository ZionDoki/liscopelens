# 开发手册

1. [开发手册](#开发手册)
   1. [目录结构](#目录结构)
   2. [主要模块说明](#主要模块说明)
      1. [程序入口](#程序入口)
      2. [工具方法](#工具方法)
      3. [规则推理](#规则推理)
      4. [项目解析](#项目解析)
   3. [逻辑视图](#逻辑视图)
   4. [环境准备](#环境准备)
      1. [使用 poetry 构建工具](#使用-poetry-构建工具)
      2. [使用默认工具调试](#使用默认工具调试)
   5. [准则](#准则)
      1. [开发准则](#开发准则)
      2. [依赖引入准则](#依赖引入准则)


## 目录结构

``` shell
lic_analyzer
    |-- data                // 数据（Knowledge Base）
    |-- dist                // 打包文件
    |-- doc                 // 项目文档
    |-- lic_analyzer
    |   |-- checker         // 兼容性检查模块
    |   |-- parser          // 项目依赖分析模块
    |   |-- utils           // 基础工具模块
    |   |-- app.py          // 工具入口
    |   |-- constants.py    // 常量、枚举类型
    |-- tests               // 单元测试
    |-- .gitignore
    |-- poetry.lock
    |-- pyproject.toml
    |-- README.md
```

## TODO

- [x] 重新调研 LGPL-2.1-only 条件兼容的情况
- [x] 重新 Schemas 中的一些命名方式使用枚举类型代替
- [ ] 进行兼容性单元测试，搭建兼容性单元测试脚手架
  - [ ] 针对GPL "or-later" 和 "Apache-2.0，curl" 进行单元测试
- [ ] hold liable 不应该作为一种限制处理

## 主要模块说明

### 程序入口

当前版本 `lict` 主要以命令行工具形式提供兼容性检查能力，项目根目录下 `app.py` 为程序入口。

### 工具方法

工具方法模块 `utils` 主要包含常用工具方法。包括**图数据接口、许可证处理接口**以及项目常用工具接口。

### 规则推理

规则推理模块 `checker` 主要包含**从结构化许可证到兼容性知识库规则推理接口、从兼容知识库到开源软件许可证兼容性检查接口**。

### 项目解析

项目解析模块 `parser` 主要包含**扫描器及对应的各类文件解析模块**。

## 逻辑视图

0. 首先通过规则推理模块（utils.infer）维护兼容性知识库
1. 检查目标仓库时，使用项目解析模块的扫描器检查项目依赖及依赖行为
2. 项目扫描器根据解析器规则匹配分发解析任务，并接收其回调存储解析结果
3. 扫描器维护并导出扫描结果（多边类型的图结构数据），包含依赖及依赖行为关系
4. 规则推理模块（utils.compatible）根据依赖及依赖行为检查兼容性规则返回最终结果

## SRLT

```toml
[special.triggering]
protect_scope = []
escape_scope = []
target = ["cannot.use_trademark", "cannot.patent_suit"]
```

## 环境准备

### 使用 poetry 构建工具

1. 参考[poetry 官方安装脚本](https://python-poetry.org/docs/#installing-with-the-official-installer)安装 poetry 包管理工具并将其**添加系统变量**。
2. 安装依赖 `poetry install`，poetry 默认将依赖安装至其管理的虚拟环境中。
3. 调试及运行 `poetry run python path/to/xxx.py`。
4. 安装其他依赖 `poetry add xxx` 

### 使用默认工具调试

1. 安装项目需要的依赖 `pip instsall .` （推荐使用虚拟环境，具体自行查阅）。
2. 调试及运行 `python xxx.py`。
3. 添加依赖，**需要手动将对应版本增加至 pyproject.toml中**。

## 准则

### 开发准则

1. 有意义的命名

    尽量避免出现 `lic_analyzer.checker.checker:{Get, Process}` 这类命名方法，应替换为 `lic_analyzer.checker.compatible:{GetPackage, ProcessSBOM}` 等具有明确含义（同时避免重名）的命名。

2. 规范的注释以及typing

    在方法、函数按照一般标准编写注释，并对函数的参数及返回进行类型标注。

3. 平横解耦与过度设计

    避免代码耦合，同时避免为了解耦而产生的过度设计。

### 依赖引入准则

1. 避免引入**不（低）活跃、未知协议**的三方依赖

## 其他信息

### OH build.gn 备注

```js
type: {
    "action": 表示这是一个操作（action）。在 gn (Generate Ninja) 文件中，操作（action）用于描述需要执行的任务或命令，通常是编译、链接、生成文件等。在这种情况下，它描述了执行某些操作以生成特定的输出文件的步骤。(一般是执行一个脚本)
    "copy": 复制操作，将一个文件复制到另一个地方
    "group": 将多个文件组织在一起,貌似并无依赖关系。大部分为空
    "executable": 可执行文件，将多个文件打包为一个二进制可执行文件
    "static_library": 多个文件打包为一个静态库，注意sources貌似是纯代码文件，而在deps中会指定依赖的其他库或者一些action动作。
    "source_set”：同样将一些文件放到一起，但是它与其他相比仅仅是放在一起而不操作
    "generated_file"：绝大部分是生成info信息json文件
    "shared_library":动态库
    "rust_library":rust库
    "rust_proc_macro":宏文件，输出同样是.so
}
```

Type: action, Count: 17404
Type: copy, Count: 542
Type: group, Count: 6548
Type: executable, Count: 3430
Type: static_library, Count: 382
Type: action_foreach, Count: 13
Type: source_set, Count: 318
Type: generated_file, Count: 2800
Type: shared_library, Count: 754
Type: rust_library, Count: 96
Type: rust_proc_macro, Count: 9


递归json。遍历全部targets。为每一个targets创建一个子典，标记依赖时应该标记类型